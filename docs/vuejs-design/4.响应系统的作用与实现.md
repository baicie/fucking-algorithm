# 响应系统的作用与实现

## 响应式数据与副作用函数

副作用函数指的是会产生副作用的函数  
我们希望当值变化后，副作用函数自动重新执行，如果能实现这个目标，那么对象 obj 就是响应式数据

## 响应式数据的基本实现

当读取字段时，可以把副作用函数 effect 存储到一个“桶”里
当设置 obj.text 时，再把副作用函数 effect 从“桶”里取出并执行即可

```javascript
        const bucket = new Set()
        const data = { text: 'hello' }

        const obj = new Proxy(data, {
            get(target, key) {
                bucket.add(effect)
                return target[key]
            },
            set(target, key, newVal) {
                target[key] = newVal
                bucket.forEach(fn => fn())
                return true
            }
        })

        function effect() {
            document.body.innerText = obj.text
        }

        effect()

        setTimeout(() => {
            obj.text = 'world vue3'
        }, 1000)
```

## 设计一个完善的响应系统

一旦副作用函数的名字不叫 effect，那么这段代码就不能正确地工作了  
希望的是，哪怕副作用函数是一个匿名函数，也能够被正确地收集到“桶”中。为了实现这一点，我们需要提供一个用来注册副作用函数的机制

```js
        let activeEffect
        function effect(fn) {
            // 当调用 effect 注册副作用函数时，将副作用函数 fn 赋值给 activeEffect
            activeEffect = fn
            fn()
        }

        const bucket = new Set()
        const data = { text: 'hello' }

        const obj = new Proxy(data, {
            get(target, key) {
                if (activeEffect) {
                    bucket.add(activeEffect)
                }
                return target[key]
            },
            set(target, key, newVal) {
                target[key] = newVal
                bucket.forEach(fn => fn())
                return true
            }
        })

        effect(() => {
            console.log('effect run');

            document.body.innerHTML = obj.text
        })

        setTimeout(() => {
            obj.text = 'hellow vue3'
        })
```

在响应式数据 obj 上设置一个不存在的属性时
导致该问题的根本原因是，我们没有在副作用函数与被操作的目标字段之间建立明确的联系

```js
        effect(() => {
            console.log('effect run');
            document.body.innerHTML = obj.text
        })
```

可以建立入夏的关联关系
target
    └── key
        └── effectFn
可能存在关联关系有
target
    └── key
        └── effectFn1
        └── effectFn2
target
    └── key1
        └── effectFn
    └── key2
        └── effectFn

```js
  const bucket = new WeakMap()
        let activeEffect
        const data = { text: 'hello' }
        const obj = new Proxy(data, {
            get(target, key) {
                if (!activeEffect) return target[key]
                // target映射
                let depsMap = bucket.get(target)
                if (!depsMap) {
                    bucket.set(target, (depsMap = new Map()))
                }
                // key - effect映射
                let deps = depsMap.get(key)
                if (!deps) {
                    depsMap.set(key, (deps = new Set()))
                }
                deps.add(activeEffect)
                return target[key]
            },
            set(target, key, newVal) {
                target[key] = newVal
                const depsMap = bucket.get(target)
                if (!depsMap) return
                const effects = depsMap.get(key)
                effects && effects.forEach(fn => fn())
            }
        })
```

- WeakMap 由 target --> Map 构成；
- Map 由 key --> Set 构成。

## 分支切换与 cleanup

存在一个三元表达式 当字段 obj.ok 的值发生变化时，代码执行的分支会跟着变化，这就是所谓的分支切换

分支切换可能会产生遗留的副作用函数

```js
const bucket = new WeakMap()
        let activeEffect
        const data = { text: 'hello', ok: true }
        const obj = new Proxy(data, {
            get(target, key) {
                track(target, key)
                return target[key]
            },
            set(target, key, newVal) {
                target[key] = newVal
                trigger(target, key)
            }
        })

        function effect(fn) {
            const effectFn = () => {
                cleanup(effectFn)
                // 当 effectFn 执行时，将其设置为当前激活的副作用函数
                activeEffect = effectFn
                fn()
            }
            // 这些deps和effectFn存在关联关系
            effectFn.deps = []
            effectFn()
        }

        function cleanup(effectFn) {
            for (let i = 0; i < effectFn.deps.length; i++) {
                const deps = effectFn.deps[i]
                //删除所有存在关系的deps中的当前的effectFn
                deps.delete(effectFn)
            }
            effectFn.deps.length = 0
        }

        function track(target, key) {
            if (!activeEffect) return
            // target映射
            let depsMap = bucket.get(target)
            if (!depsMap) {
                bucket.set(target, (depsMap = new Map()))
            }
            // key - effect映射
            let deps = depsMap.get(key)
            if (!deps) {
                depsMap.set(key, (deps = new Set()))
            }
            deps.add(activeEffect)
            activeEffect.deps.push(deps)
        }

        function trigger(target, key) {
            const depsMap = bucket.get(target)
            if (!depsMap) return
            const effects = depsMap.get(key)
            const effectsToRun = new Set(effects)
            effectsToRun.forEach(effectFn => effectFn())
        }

        effect(() => {
            console.log('effect run');
            document.body.innerHTML = obj.ok ? obj.text : 'not'
        })

        setTimeout(() => {
            obj.ok = false
            obj.text = 'hello vue3'
        }, 3000)

```

## 嵌套的 effect 与 effect 栈

存在嵌套时会导致 当副作用函数发生嵌套时，内层副作用函数的执行会覆盖 activeEffect 的值，并且永远不会恢复到原来的值 收集到的副作用函数也都会是内层副作用函数

```js
const bucket = new WeakMap()
        let activeEffect
        const effectStack = []
        const data = { text: 'hello', ok: true }
        const obj = new Proxy(data, {
            get(target, key) {
                track(target, key)
                return target[key]
            },
            set(target, key, newVal) {
                target[key] = newVal
                trigger(target, key)
            }
        })

        function effect(fn) {
            const effectFn = () => {
                cleanup(effectFn)
                activeEffect = effectFn
                effectStack.push(effectFn)
                fn()
                effectStack.pop()
                activeEffect = effectStack[effectStack.length - 1]
            }
            // 这些deps和effectFn存在关联关系
            effectFn.deps = []
            effectFn()
        }

        function cleanup(effectFn) {
            for (let i = 0; i < effectFn.deps.length; i++) {
                const deps = effectFn.deps[i]
                //删除所有存在关系的deps中的当前的effectFn
                deps.delete(effectFn)
            }
            effectFn.deps.length = 0
        }

        function track(target, key) {
            if (!activeEffect) return
            // target映射
            let depsMap = bucket.get(target)
            if (!depsMap) {
                bucket.set(target, (depsMap = new Map()))
            }
            // key - effect映射
            let deps = depsMap.get(key)
            if (!deps) {
                depsMap.set(key, (deps = new Set()))
            }
            deps.add(activeEffect)
            activeEffect.deps.push(deps)
        }

        function trigger(target, key) {
            const depsMap = bucket.get(target)
            if (!depsMap) return
            const effects = depsMap.get(key)
            const effectsToRun = new Set(effects)
            effectsToRun.forEach(effectFn => effectFn())
        }
        let temp1, temp2
        effect(() => {
            console.log('1 run');
            effect(() => {
                console.log('2 run');
                temp1 = obj.ok
            })
            temp2 = obj.text
        })
```

## 避免无限递归循环
