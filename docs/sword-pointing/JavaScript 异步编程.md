### JavaScript 异步编程
js是一种同步的、阻塞的、单线程的语言，一次职能执行一个任务。但是浏览器定义了非同步的Web Apis，将回调函数插入到事件循环，实现异步任务的非阻塞执行。常见的异步方案由异步回调、定时器、发布/订阅模式、Promise、生成器、aysnc/await、以及web worker

1. 异步回调
异步回调函数作为参数传递给在后台执行的其他函数。当后台运行的代码结束，就调用回调函数，通知工作已经完成。
存在问题：
- 回调表达异步流程的方式是非线性的，非顺序的，理解成本较高
- 回调回收到控制反转的影响
- 多层嵌套会导致回调地狱

2. 定时器
 1. setTimeout：经过任意时间后运行函数，递归 setTimeout 在 JavaScript 线程不阻塞的情况下可保证执行间隔相同。
 2. setInterval：允许重复执行一个函数，并设置时间间隔，不能保证执行间隔相同。
 3. requestAnimationFrame：以当前浏览器/系统的最佳帧速率重复且高效地运行函数的方法。一般用于处理动画效果。

3. 发布订阅模式
发布/订阅模式是一种对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到状态改变的通知。

4. Promise
Promise 提供了完成和拒绝两个状态来标识异步操作结果，通过 then 和 catch 可以分别对着两个状态进行跟踪处理。和事件监听的主要差别在于：

 1. 一个 Promise 只能成功或失败一次，一旦状态改变，就无法从成功切换到失败，反之亦然。
 2. 如果 Promise 成功或失败，那么即使在事件发生之后添加成功/失败回调，也将调用正确的回调。

5. 生成器
Generator 函数是 ES6 提供的一种异步编程解决方案，语法与传统函数完全不同，最大的特点就是可以控制函数的执行

生成器 Generator 保持了顺序、同步、阻塞的代码模式，同样解决了异步回调的问题。

6. async/await

具有如下特点：
 1. async/await 不能用于普通的回调函数。
 2. async/await 与 Promise 一样，是非阻塞的。
 3. async/await 使得异步代码看起来像同步代码。
存在的问题：
await 关键字会阻塞其后的代码，直到 Promise 完成，就像执行同步操作一样。它可以允许其他任务在此期间继续运行，但自己的代码会被阻塞。

7. web worker
Web Worker 为 JavaScript 创造了多线程环境。允许主线程创建 Worker 线程，将一些任务分配给 Worker 线程运行，处理完后可以通过 postMessage 将结果传递给主线程。优点在于可以在一个单独的线程中执行费时的处理任务，从而允许主线程中的任务（通常是 UI）运行不被阻塞/放慢

问题：
1. 在 Worker 内部无法访问主线程的任何资源，包括全局变量，页面的 DOM 或者其他资源，因为这是一个完全独立的线程。
2. Worker 和主线程间的数据传递通过消息机制进行。使用 postMessage 方法发送消息；使用 onmessage 事件处理函数来响应消息。
3. Worker 可以创建新的 Worker，新的 Worker 和父页面同源。Worker 在使用 XMLHttpRequest 进行网络 I/O 时，XMLHttpRequest 的 responseXML 和 channel 属性会返回 null。