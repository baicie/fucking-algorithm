### 垃圾回收机制

GC是一种内存自动管理机制，垃圾回收器可以自动回收分配给程序已经不在使用的内存。常见的GC算法有引用计数法和标记清除法。V8的垃圾回收主要有标记整理（Mark-Compact）和Scavenger组成

#### 内存泄露

内存泄露值得是，当应该被回收的对象没有被正常回收，变成常驻老生代对象，导致内存占用越来越高。内存泄露会导致程序速度变慢、延时高、崩溃等问题

1. 内存的生命周期

- 分配：按需分配内存
- 使用：读写已分配的内存
- 释放：释放不再需要的内存

2. 内存泄漏常见的原因

- 创建全局变量，且没有手动回收
- 事件监听器/定时器/闭包等未正常清理
- 使用js对象来做缓存，且不设置过期策略和对象大小控制

#### 引用计数

reference counting 是常见的垃圾回收算法，其核心思路是：将资源的被引用次数保存起来，当被引用次数为零时释放。该方法的局限性：当出现循环引用时，互相引用的对象不会被回收。

#### v8的垃圾回收机制

v8中有两个垃圾回收器。主要是GC使用Mark-Compact垃圾回收算法，从整个堆中收集垃圾。小型GC使用Scavenger垃圾会算法，收集新生代垃圾

- 使用Scavenger算法主要处理存活周期短的对象中的可访问对象
- 使用Mark-Compact算法主要处理存活周期长的对象中的不可访问对象

因为新生代中存活的可访问对象占少数，老生代中的不可访问对象占少数，所以这两种算法配合使用十分高效

##### 分代垃圾收集

在v8中所有的js对象通过堆来分配。v8将其管理的堆分为两代：新生代和老生代。新生代被分成两个等大小的空间：From 空间 和 To 空间

##### Mark-Compact算法

标记整理算法可以看作标记清除算法和复制算法的结合。该算法主要分为三个阶段：标记、清除、整理。

1. 标记
    标记是找所有可访问对象的过程。GC一般会从一组已知对象指针（称为根集，包括执行堆栈和全局对象等）中，进行递归标记可访问对象。
2. 清除  清除是将不可访问的对象留下的内存空间，添加到空闲链表的过程。未来为新对象分配内存时，可从空闲链表中进行再分配
3. 整理  整理是将可访问的对象。往内存一端移动的过程。主要解决标记清除阶段后，内存空间出现较多内存碎片时候，可能导致无法分配大对象，而提前触发垃圾回收的问题

##### Scavenger算法

V8对新生代内存空间采用了Scavenger算法，该算法使用了semi-space半空间设计：将堆一分为二，始终只使用一般的空间：From-space为使用空间，To-space为空闲空间
新生代在From-Space中分配对象；在垃圾回收阶段，检查并按需复制From-Space中的可访问对象到To-Space或老生代，并释放From-Space中的不可访问对象占用的内存空间；最后交换角色

（活动对象保存在From，GC时将活动对象复制到To，清除From，然后交换From和To的角色）
